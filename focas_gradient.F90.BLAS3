module focas_gradient
  use focas_data
 
  implicit none

  contains

  subroutine orbital_gradient(int1,int2,den1,den2)
    implicit none
    real(wp), intent(in) :: int1(:),int2(:),den1(:),den2(:)
    integer :: omp_get_max_threads
    real(wp) :: t0,t1

    write(fid_,*)'************'
    write(fid_,*)'new gradient'
    write(fid_,*)'************'

    ! calculate inactive Fock matrix
    t0=timer()
    if ( df_vars_%use_df_teints == 0 ) then
      call compute_f_i(int1,int2)
    else
      call compute_f_i_df(int1,int2)
    endif
    t1=timer()
    write(fid_,'(a5,1x,f10.6)')'f_i',t1-t0

    ! calculate active Fock matrix
    t0=timer()
    if ( df_vars_%use_df_teints == 0 ) then
      call compute_f_a(den1,int2)
    else
      call compute_f_a_df(den1,int2)
    endif
    t1=timer()
    write(fid_,'(a5,1x,f10.6)')'f_a',t1-t0

    ! calculate auxiliary q matrix
    t0=timer()
    if ( df_vars_%use_df_teints == 0 ) then
      call compute_q(den2,int2)
    else
      call compute_q_df(den2,int2)
    endif
    t1=timer()
    write(fid_,'(a5,1x,f10.6)')'q',t1-t0

    ! calculate auxiliary z matrix
    t0=timer()
    call compute_z(den1)
    t1=timer()
    write(fid_,'(a5,1x,f10.6)')'z',t1-t0 
    write(fid_,*)
    call flush(fid_)

    ! compute gradient
    call compute_orbital_gradient()

!    ! print the gradient 
!    if ( log_print_ == 1 ) call print_orbital_gradient()

    return
  end subroutine orbital_gradient

  subroutine print_orbital_gradient()
    implicit none
    integer :: ij_pair,i,j,newline,i_class,j_class,j_class_start,j_start,i_sym
    character(1) :: ityp,jtyp
    ! loop over rotation pairs

    write(fid_,'(a)')'orbital gradient:'

    newline=0

    ! the loop structure below cycles through the possible rotation pairs
    ! rotation pairs are sorted according to symmetry and for each irrep,
    ! the rotation pairs are sorted according to orbital classes: ad,ed,aa,ea
    ! for each pair j>i; for more details, see subroutine setup_rotation_indeces in focas_main.F90

    ij_pair = 0

    do i_sym = 1 , nirrep_

      do i_class = 1 , 3

        j_class_start = i_class + 1

        if ( ( include_aa_rot_ == 1 ) .and. ( i_class == 2 ) ) j_class_start = i_class

        do j_class = j_class_start , 3

          do i = first_index_(i_sym,i_class) , last_index_(i_sym,i_class)

            j_start = first_index_(i_sym,j_class)

            if ( i_class == j_class ) j_start = i + 1

            do j = j_start , last_index_(i_sym,j_class)

              if ( i_class == 1 ) then

                ityp = 'd'

                jtyp = 'a'

                if ( j_class == 3 ) jtyp = 'e'

              else

                ityp = 'a'

                jtyp = 'a'

                if ( j_class == 3 ) jtyp = 'e'

              end if

              ij_pair = ij_pair + 1

              write(fid_,'(a,a,a,a,i3,a,i3,a,1x,es10.3,4x)',advance='no')jtyp,'-',ityp,' (',j,',',i,')',orbital_gradient_(ij_pair)

              newline = newline + 1

              if ( mod(newline,4) == 0 ) write(fid_,*)

            end do

          end do
 
        end do
 
      end do 

    end do
    if ( mod(newline,4) /= 0 ) write(fid_,*)

    write(fid_,'(a,1x,es10.3)')'gradient norm:',grad_norm_

    call flush(fid_)

    return

  end subroutine print_orbital_gradient

  subroutine compute_orbital_gradient()

    ! subroutine to compute the orbital gradient without explicit storage
    ! of the generalized Fock matrix

    implicit none

    integer :: grad_ind
    integer :: a_sym,t_sym
    integer :: i,t,u,a
    integer :: ia,it
    real(wp) :: ddot

    orbital_gradient_ = 0.0_wp

    ! ********************************
    ! external - doubly-occupied pairs
    ! ********************************

    do a_sym = 1 , nirrep_

      grad_ind = rot_pair_%pair_offset(a_sym,rot_pair_%ext_doc_type)

      do i = first_index_(a_sym,1) , last_index_(a_sym,1)

        do a = first_index_(a_sym,3) , last_index_(a_sym,3)
  
          grad_ind = grad_ind + 1

          ia = ints_%gemind(i,a)

          orbital_gradient_(grad_ind) = 4.0_wp*(fock_i_(ia)+fock_a_(ia))

        end do

      end do
 
    end do  

    ! ******************************
    ! acitve - doubly-occupied pairs
    ! ******************************

    do t_sym = 1 , nirrep_

      grad_ind = rot_pair_%pair_offset(t_sym,rot_pair_%act_doc_type)

      do i = first_index_(t_sym,1) , last_index_(t_sym,1)

        do t = first_index_(t_sym,2) , last_index_(t_sym,2)

          grad_ind = grad_ind + 1

          it = ints_%gemind(i,t)

          orbital_gradient_(grad_ind) = 4.0_wp*(fock_i_(it)+fock_a_(it)) - 2.0_wp * ( q_(t - ndoc_tot_,i) + z_(t - ndoc_tot_,i))

        end do

      end do

    end do

    ! ***********************
    ! external - active pairs
    ! ***********************

    do a_sym = 1 , nirrep_

      grad_ind = rot_pair_%pair_offset(a_sym,rot_pair_%ext_act_type)

      do t = first_index_(a_sym,2) , last_index_(a_sym,2)

        do a = first_index_(a_sym,3) , last_index_(a_sym,3)

          grad_ind = grad_ind + 1

          orbital_gradient_(grad_ind) = 2.0_wp * ( q_(t - ndoc_tot_,a) + z_(t - ndoc_tot_,a))

        end do
    
      end do

    end do

    ! *********************
    ! active - active pairs
    ! *********************

    if ( include_aa_rot_ == 1 ) then

      do t_sym = 1 , nirrep_

        grad_ind = rot_pair_%pair_offset(t_sym,rot_pair_%act_act_type)

        do u = first_index_(t_sym,2) , last_index_(t_sym,2)

          do t = u + 1 , last_index_(t_sym,2)

            grad_ind = grad_ind + 1

            orbital_gradient_(grad_ind) = 2.0_wp * ( q_(u - ndoc_tot_,t) + &
                 & z_(u - ndoc_tot_,t) - q_(t - ndoc_tot_,u) - z_(t - ndoc_tot_,u))

          end do
 
        end do

      end do

    end if

    grad_norm_ = sqrt(ddot(rot_pair_%n_tot,orbital_gradient_,1,orbital_gradient_,1))

    return 

  end subroutine compute_orbital_gradient

  subroutine compute_z(den1)
    implicit none
    ! function to compute contraction of the density with the inactive Fock matrix according to
    ! z(m,t) = sum_u { den1(tu) * f_i(mu) } t,u \in A m \in D,A,E
    real(wp), intent(in) :: den1(:)
    integer :: t,u,tu_den,mu_int,t_sym,m,m_class
    real(wp) :: val

    ! initialize output

    z_ = 0.0_wp

    ! loop over symmetries for t

    do t_sym = 1 , nirrep_

      ! loop over u indeces

      do t = first_index_(t_sym,2) , last_index_(t_sym,2)

        ! loop over classes for m

        do m_class = 1 , 3

          ! loop over m indeces
 
          do m = first_index_(t_sym,m_class) , last_index_(t_sym,m_class)

            ! initialize contraction value

            val = 0.0_wp

            do u = first_index_(t_sym,2) , last_index_(t_sym,2)

              ! integral/density addressing

              tu_den = dens_%gemind(t,u)
              mu_int = ints_%gemind(m,u)

              val = val + den1(tu_den) * fock_i_(mu_int)

            end do ! end u loop

            z_( t - ndoc_tot_ , m ) = val 

          end do ! end m loop

        end do ! end m_class loop

      end do ! end t loop

    end do ! end t_sym loop

    return

  end subroutine compute_z

  subroutine compute_q_df(den2,int2)
    implicit none
    ! this subroutine computes the "auxiliary Q" matrix according to Eq. 12.5.14 in Helgaker on page 622
    ! Q(v,m) = \SUM[w,x,y \in A] { d2(vw|xy) * g(mw|xy) }
    ! Because only those D2 elements with all four indeces \in A are nonzero, we have v \in A
    ! Also, m is a general orbital index && sym_m == sym_v
    ! Integrals are stored in 3-index format. Instead of doing many ddots, the set of integrals
    ! (mw|xy) is computed using dgemm g(mw|xy) = sum_Q xy_df(xy,Q) * mw_df(Q,mw) 
    ! this requires extra storage but not too much:  g ~ nact^3 xy_df ~ nQ*nirrep*nact^2 mw_df ~ nQ*nact   
    real(wp), intent(in) :: den2(:),int2(:)
    integer :: mw_sym,x_sym,y_sym,w_sym,m_sym,m_class,m,v,w,x,y,mdf,wdf,xdf,ydf
    integer :: xy_den,vw_den
    integer(ip) :: mw,xy,nQ
    integer :: den_ind,den_sym_offset,int_col,int_row,y_last
    integer :: imw,ixy
    integer :: max_nmopi,max_ngempi,error
    real(wp) :: val,int_val,ddot
    real(wp) :: v_mw(df_vars_%nQ)

    type sym_block
      real(wp), allocatable :: mw_df(:,:)
      real(wp), allocatable :: xy_df(:,:)
      real(wp), allocatable :: ints(:,:)
    end type sym_block

    type(sym_block) :: df_q(nirrep_)

    nQ = int(df_vars_%nQ,kind=ip)

    max_nmopi  = maxval(nactpi_)
    max_ngempi = max_nmopi * max_nmopi 

    error = allocate_df_q()

    ! initialize
    q_ = 0.0_wp

    ! loop over symmetries for m

    do m_sym = 1 , nirrep_

      ! loop over classes for m

      do m_class = 1 , 3

        ! loop over orbital index m

        do m = first_index_(m_sym,m_class) , last_index_(m_sym,m_class)

          ! m index in df order

          mdf = df_vars_%class_to_df_map(m)

          ! *************************************
          ! gather df integrals (:|mw) and (:|xy)
          ! *************************************

          do w_sym = 1 , nirrep_

            if ( nactpi_(w_sym) == 0 ) cycle
    
            imw = 0    

            mw_sym = group_mult_tab_(m_sym,w_sym)

            do w = first_index_(w_sym,2) , last_index_(w_sym,2)
 
              wdf = df_vars_%class_to_df_map(w)
 
              mw  = df_pq_index(wdf,mdf)

              imw = imw + 1

              call dcopy(nQ,int2(mw+1:mw+nQ),1,df_q(w_sym)%mw_df(:,imw),1)

            end do ! end w loop

            ixy = 0

            do x_sym = 1 , nirrep_

              y_sym = group_mult_tab_(x_sym,mw_sym)
 
              if ( y_sym > x_sym ) cycle

              do x = first_index_(x_sym,2) , last_index_(x_sym,2) 

                xdf = df_vars_%class_to_df_map(x)

                y_last = last_index_(y_sym,2)
                if ( y_sym == x_sym ) y_last = x

                do y = first_index_(y_sym,2) , y_last

                  ydf     = df_vars_%class_to_df_map(y)

                  xy      = df_pq_index(xdf,ydf)

                  ixy     = ixy + 1

                  call dcopy(df_vars_%nQ,int2(xy+1:xy+nQ),1,df_q(w_sym)%xy_df(:,ixy),1)

                end do ! end y loop  

              end do ! end x loop

            end do ! end x_sym loop

            if ( ixy == 0 ) cycle

            ! *******************************************************************************************
            ! multiply 3-index integral matrices to get the 4-index integrals (xy|mw) for all w,x,y \in A
            ! *******************************************************************************************

            call dgemm('t','n',ixy,imw,df_vars_%nQ,         &
                     & 1.0_wp,df_q(w_sym)%xy_df(:,1:ixy),df_vars_%nQ,&
                     &        df_q(w_sym)%mw_df(:,1:imw),df_vars_%nQ,&
                     & 0.0_wp,df_q(w_sym)%ints,nirrep_*max_ngempi)

          end do ! end w_sym loop

          ! loop over orbital index v

#ifdef OMP
!$omp parallel shared(m_class,nQ,m_sym,m,mdf,first_index_,last_index_,df_vars_,den2,int2,dens_,q_) num_threads(nthread_use_)
!$omp do private(ixy,imw,val,v,w_sym,mw_sym,den_sym_offset,w,vw_den,x_sym,y_sym,x,y,xy_den,den_ind,int_val)
#endif

          do v = first_index_(m_sym,2) , last_index_(m_sym,2)

            ! initialize matrix element
  
            val = 0.0_wp

            ! loop over symmetries for w

            do w_sym = 1 , nirrep_

              imw = 0

              ! symmetry of mw geminal

              mw_sym = group_mult_tab_(m_sym,w_sym)

              ! vw density offset 
             
              den_sym_offset = dens_%offset(mw_sym)

              ! loop over w orbital index
 
              do w = first_index_(w_sym,2) , last_index_(w_sym,2)

                ixy = 0   

                imw = imw + 1

                ! vw geminal index for density

                vw_den = dens_%gemind(v,w)

                ! loop over x_sym

                do x_sym = 1 , nirrep_

                  ! figure out symmetry of y

                  y_sym = group_mult_tab_(mw_sym,x_sym)

                  if ( y_sym == x_sym ) then
                 
                    ! loop over x orbital index
 
                    do x = first_index_(x_sym,2) , last_index_(x_sym,2)

                      ! ***********************************************
                      ! loop over y orbital index (x>y) --> factor of 2
                      ! ***********************************************

                      do y = first_index_(y_sym,2) , x - 1

                        ixy = ixy + 1

                        ! xy geminal index and density index

                        xy_den  = dens_%gemind(x,y)
                        den_ind = pq_index(vw_den,xy_den) + den_sym_offset
                    
                        ! update matrix element
                        val = val + 2.0_wp * df_q(w_sym)%ints(ixy,imw) * den2(den_ind)

                      end do ! end y loop

                      ! **********************
                      ! x == y --> factor of 1
                      ! **********************

                      xy_den  = dens_%gemind(x,x)
                      den_ind = pq_index(vw_den,xy_den) + den_sym_offset

                      ixy = ixy + 1

                      ! xy geminal index in df order
                      xy  = df_pq_index(xdf,xdf) 

                      ! update matrix element
                      val = val + df_q(w_sym)%ints(ixy,imw) * den2(den_ind)

                    end do ! end x loop

                  elseif ( y_sym < x_sym) then

                    ! loop over x orbital index

                    do x = first_index_(x_sym,2) , last_index_(x_sym,2)

                      ! ***********************************************
                      ! loop over y orbital index (x>y) --> factor of 2
                      ! ***********************************************

                      do y = first_index_(y_sym,2) , last_index_(y_sym,2)

                        ! xy geminal index and density index

                        xy_den  = dens_%gemind(x,y)
                        den_ind = pq_index(vw_den,xy_den) + den_sym_offset

                        ixy = ixy + 1

                        ! update matrix element
                        val = val + 2.0_wp * df_q(w_sym)%ints(ixy,imw) * den2(den_ind)

                      end do ! end y loop

                    end do ! end x loop

                  endif 

                end do ! end x_sym loop

              end do ! end w loop

            end do ! end w_sym loop

            ! save matrix element

            q_( v - ndoc_tot_ , m ) = val
           
          end do ! end v loop

#ifdef OMP
!$omp end do nowait
!$omp end parallel
#endif

        end do ! end m loop

      end do ! end m_class loop 

    end do ! end m_sym loop
 
    error = deallocate_df_q()

    return

    contains

      integer function allocate_df_q()

        implicit none

        integer :: w_sym

        do w_sym = 1 , nirrep_

          if ( nactpi_(w_sym) == 0 ) cycle
 
          allocate(df_q(w_sym)%mw_df(df_vars_%nQ,nactpi_(w_sym)))
          allocate(df_q(w_sym)%xy_df(df_vars_%nQ,nirrep_*max_ngempi))
          allocate(df_q(w_sym)%ints(nirrep_*max_ngempi,max_nmopi)) 

        end do
 
        allocate_df_q = 0

      end function allocate_df_q

      integer function deallocate_df_q()

        integer :: w_sym

        do w_sym = 1 , nirrep_       

          if (allocated(df_q(w_sym)%mw_df)) deallocate(df_q(w_sym)%mw_df)
          if (allocated(df_q(w_sym)%xy_df)) deallocate(df_q(w_sym)%xy_df)
          if (allocated(df_q(w_sym)%ints))  deallocate(df_q(w_sym)%ints)

        end do

        deallocate_df_q = 0

      end function deallocate_df_q

  end subroutine compute_q_df

  subroutine compute_q(den2,int2)
    implicit none
    ! this subroutine computes the "auxiliary Q" matrix according to Eq. 12.5.14 in Helgaker on page 622
    ! Q(v,m) = \SUM[w,x,y \in A] { d2(vw|xy) * g(mw|xy) }
    ! Because only those D2 elements with all four indeces \in A are nonzero, we have v \in A
    ! Also, m is a general orbital index && sym_m == sym_v
    real(wp), intent(in) :: den2(:),int2(:)   
    integer :: mw_sym,x_sym,y_sym,w_sym,m_sym,m_class,m,v,w,x,y
    integer :: xy_den,xy_int,mw,vw
    integer :: den_ind,den_sym_offset,int_ind,int_sym_offset
    real(wp) :: val

    ! initialize
    q_ = 0.0_wp

    ! loop irreps for m and v

    do m_sym = 1 , nirrep_
 
      ! loop over irreps for w

      do w_sym = 1, nirrep_

        ! mw//vw symmetry
        mw_sym = group_mult_tab_(m_sym,w_sym)
        ! offsets for integral/density addressing
        den_sym_offset = dens_%offset(mw_sym)
        int_sym_offset = ints_%offset(mw_sym)

        ! loop over irreps for x

        do x_sym = 1 , nirrep_

          ! correspoing irrep for y
          y_sym = group_mult_tab_(x_sym,mw_sym)

          ! at this point, we have mw_sym == xy_sym && m_sym == v_sym
          ! loop over m_class

          do m_class = 1 , 3

            ! loop over v indeces
   
            do m = first_index_(m_sym,m_class) , last_index_(m_sym,m_class)

              ! loop over v \in A

              do v = first_index_(m_sym,2) , last_index_(m_sym,2)

                ! initialize q matrix element
                val     = 0.0_wp

                ! loop over w indeces

                do w = first_index_(w_sym,2) , last_index_(w_sym,2)
                  
                  ! save geminal indeces for integral/density addressing
                  mw = ints_%gemind(m,w)
                  vw = dens_%gemind(v,w)

                  ! loop over x indeces
 
                  do x = first_index_(x_sym,2) , last_index_(x_sym,2)

                    ! loop over y indeces

                    do y = first_index_(y_sym,2) , last_index_(y_sym,2) 

                      ! save geminal indeces for integral/density addressing
                      xy_int  = ints_%gemind(x,y)
                      xy_den  = dens_%gemind(x,y)
                      ! integral/density addresses
                      int_ind = pq_index(xy_int,mw) + int_sym_offset                      
                      den_ind = pq_index(xy_den,vw) + den_sym_offset
                      ! update temporary value
                      val     = val + den2(den_ind) * int2(int_ind)
 
                    end do ! end y loop

                  end do ! end x loop
                   
                end do ! end w loop

                ! update q matrix element
                q_( v - ndoc_tot_ , m ) = q_( v - ndoc_tot_ , m ) + val

              end do ! end v loop

            end do ! end m loop 

          end do ! end m_class loop

        end do ! end x_sym loop

      end do ! end w_sym loop

    end do ! end m_sym loop

    return
  end subroutine compute_q

  subroutine compute_f_a_df(den1,int2)
    implicit none
    ! this subroutine computes the "active fock matrix" according to Eq. 12.5.13 in Helgaker on page 622
    ! F_a(m|n) = h(m|n) + SUM[v,w \in A] { g(mn|vw) - 0.5 g(mw|vn) }
    ! Apart from the symmetry constraint m_sym == n_sym and m >= n, m and n can belong to either of the three
    ! orbital classes.
    ! v and w belong to the active orbital class
    real(wp), intent(in) :: den1(:),int2(:)
    integer :: m_class,n_class,m_sym,m,n,v,w,w_sym,mdf,ndf,wdf,vdf
    integer :: den_ind,mn_fock
    integer(ip) :: mn,vw,mw,nQ
    integer :: max_nmopi,max_nactpi
    integer :: m_dgemm,n_dgemm,k_dgemm,mc_l,mc_f
    integer :: df_ind,error,mn_J
    integer :: coulomb_ind,exchange_row,exchange_col
    real(wp) :: val,ival,dval,ddot
    real(wp) :: v_mn(df_vars_%nQ),v_mw(df_vars_%nQ)

    type df_int_block
      real(wp), allocatable :: df_int(:,:)
    end type df_int_block

    type w_sym_block
      type(df_int_block), allocatable :: w_irr(:)
    end type w_sym_block

    type m_sym_block  
      type(w_sym_block), allocatable :: m_irr(:)
    end type m_sym_block

    type int_block
      real(wp), allocatable :: ints(:,:)
    end type int_block

    type(int_block)  :: Km(nirrep_)
    type(int_block)  :: Jm(nirrep_)

    type(m_sym_block)  :: mw_df
    type(w_sym_block)  :: vw_df
    type(df_int_block) :: mn_df

    nQ = int(df_vars_%nQ,kind=ip)

    max_nmopi = maxval(trans_%nmopi)
    max_nactpi = maxval(nactpi_)

    error = allocate_df_fa()

    ! *****************************
    ! collect all mw df vectors 
    ! m is a general orbital index
    ! w is an active orbital index
    ! this adds nQ*nact*nmo storage
    ! *****************************

    do m_sym = 1 , nirrep_

      do w_sym = 1 , nirrep_

        df_ind = 0

        do m_class = 1 , 3

          do m = first_index_(m_sym,m_class) , last_index_(m_sym,m_class)

            mdf = df_vars_%class_to_df_map(m)

            do w = first_index_(w_sym,2) , last_index_(w_sym,2)

              wdf    = df_vars_%class_to_df_map(w)

              mw     = df_pq_index(mdf,wdf)

              df_ind = df_ind + 1

              call dcopy(df_vars_%nQ,int2(mw+1:mw+nQ),1,mw_df%m_irr(m_sym)%w_irr(w_sym)%df_int(:,df_ind),1)

            end do

          end do

        end do

      end do

    end do

    ! ******************************************
    ! collect all vw df vectors
    ! v&w are both active orbital indeces
    ! this adds nQ*nact*(nact+1)/2 extra storage
    ! ******************************************

    do w_sym = 1 ,nirrep_

      df_ind = 0

      do w = first_index_(w_sym,2) , last_index_(w_sym,2)

        wdf = df_vars_%class_to_df_map(w)

        do v = first_index_(w_sym,2) , w

          vdf = df_vars_%class_to_df_map(v)
 
          vw  = df_pq_index(vdf,wdf) 

          df_ind = df_ind + 1
          
          call dcopy(df_vars_%nQ,int2(vw+1:vw+nQ),1,vw_df%w_irr(w_sym)%df_int(:,df_ind),1)
 
        end do

      end do
 
    end do

    ! initialize
    fock_a_ = 0.0_wp

    ! loop over orbital classes for m

    do m_class = 1 , 3

      ! loop over irreps (m_sym == n_sym for F(m,n) != 0)

      do m_sym = 1 , nirrep_

        ! loop over m indeces

        do m = first_index_(m_sym,m_class) , last_index_(m_sym,m_class)

          ! orbital index in df order
          mdf = df_vars_%class_to_df_map(m)

          ! **********************************
          ! gather ALL df integrals for this m
          ! this adds nQ*nmo extra storage
          ! **********************************

          df_ind = 0

          ! this used to include all classes
          do n_class = 1 , m_class

            do n = first_index_(m_sym,n_class) , last_index_(m_sym,n_class)

              ndf = df_vars_%class_to_df_map(n)

              mn = df_pq_index(mdf,ndf)

              df_ind = df_ind + 1

              call dcopy(df_vars_%nQ,int2(mn+1:mn+nQ),1,mn_df%df_int(:,df_ind),1)

            end do

          end do

          ! *******************************************************
          ! form ALL exchange/coulomb integrals for this value of m
          ! this adds 2 * nact*nact*nmo extra storage
          ! *******************************************************

          do w_sym = 1 , nirrep_

            if ( nactpi_(w_sym) == 0 ) cycle   

            mc_f = ( trans_%class_to_irrep_map(m) - 1 ) * nactpi_(w_sym)
            mc_l = mc_f + nactpi_(w_sym)

            m_dgemm = nactpi_(w_sym) * trans_%nmopi(m_sym)
            n_dgemm = nactpi_(w_sym)
            k_dgemm = df_vars_%nQ

            if ( ( m_dgemm > 0 ) .and. ( n_dgemm > 0 ) ) then

              call dgemm('t','n',m_dgemm,n_dgemm,k_dgemm,1.0_wp,                        &
                       & mw_df%m_irr(m_sym)%w_irr(w_sym)%df_int,k_dgemm,                &
                       & mw_df%m_irr(m_sym)%w_irr(w_sym)%df_int(:,mc_f+1:mc_l),k_dgemm, &
                     & 0.0_wp,Km(w_sym)%ints(1:m_dgemm,1:n_dgemm),m_dgemm)

            end if

            m_dgemm = nactpi_(w_sym) * ( nactpi_(w_sym) + 1 ) /2
            n_dgemm = df_ind !trans_%nmopi(m_sym)

            if ( ( m_dgemm > 0 ) .and. ( n_dgemm > 0 ) ) then    

              ! vw --> df_int [ nQ          , na*(na+1)/2 ]
              ! mn --> df_int [ nQ          , max_nmo     ]
              ! Jm -->        [ na*(na+1)/2 , max_nmo     ]

              call dgemm('t','n',m_dgemm,n_dgemm,k_dgemm,1.0_wp,vw_df%w_irr(w_sym)%df_int, &
                       & k_dgemm,mn_df%df_int(:,1:n_dgemm),k_dgemm,0.0_wp,                 & 
                       & Jm(w_sym)%ints(:,1:n_dgemm),m_dgemm)

            end if

          end do
 
          ! loop over n indeces ( m_class == n_class && m >= n && m_sym == n_sym )

#ifdef OMP
!$omp parallel shared(m_sym,m_class,m,nirrep_,first_index_,trans_,den1,Jm,Km,nactpi_) num_threads(nthread_use_)
!$omp do private(n,mn_J,val,den_ind,w_sym,coulomb_ind,exchange_col,w,exchange_row,v)
#endif

          do n = first_index_(m_sym,m_class) , m

            mn_J = trans_%class_to_irrep_map(n)

            ! initialize Fock matrix element
            val = 0.0_wp

            ! loop over irreps for v

            den_ind = 0

            do w_sym = 1 , nirrep_

              coulomb_ind  = 0 
              exchange_col = 0

              ! loop over w indeces

              do w = 1, nactpi_(w_sym) !first_index_(w_sym,2) , last_index_(w_sym,2)

                exchange_row = df_ga_index(n,first_index_(w_sym,2),w_sym) - 1
 
                exchange_col = exchange_col + 1

                ! *** w > v --> factor of 2

                ! loop over v indeces

                do v = 1 , w - 1 !first_index_(w_sym,2) , w - 1 

                  den_ind      = den_ind + 1
                  coulomb_ind  = coulomb_ind + 1
                  exchange_row = exchange_row + 1

                  ! :: d1(v|w) * [ 2 * g(mn|vw) - g(mw|wn) ]
                  val = val + den1(den_ind) * ( 2.0_wp * Jm(w_sym)%ints(coulomb_ind,mn_J) - & 
                                            &  Km(w_sym)%ints(exchange_row,exchange_col) )

                end do ! end v loop

                ! **** w == v --> factor of 1

                den_ind      = den_ind + 1
                coulomb_ind  = coulomb_ind + 1
                exchange_row = exchange_row + 1
 
                ! :: d1(v|w) * [ g(mn|vw) - 0.5 * g(mw|wn) ]
                val = val + den1(den_ind) * ( Jm(w_sym)%ints(coulomb_ind,mn_J) -  &
                                          & 0.5_wp * Km(w_sym)%ints(exchange_row,exchange_col) )

              end do ! end w loop

            end do ! end w_sym loop

            ! save Fock matrix element
            mn_fock          = ints_%gemind(m,n)
            fock_a_(mn_fock) = val

          end do ! end n loop

#ifdef OMP
!$omp end do nowait
!$omp end parallel
#endif

          ! loop over orbital classes for n (n_class < m_class --> n < m) 

          do n_class = 1 , m_class - 1

            ! loop over n indeces

#ifdef OMP
!$omp parallel shared(m_sym,n_class,m,nirrep_,first_index_,trans_,den1,Jm,Km,nactpi_) num_threads(nthread_use_)
!$omp do private(n,mn_J,val,den_ind,w_sym,coulomb_ind,exchange_col,w,exchange_row,v)
#endif


            do n = first_index_(m_sym,n_class) , last_index_(m_sym,n_class)

              mn_J = trans_%class_to_irrep_map(n)

              ! initialize Fock matrix element
              val = 0.0_wp

              den_ind = 0

              ! loop over irreps for v

              do w_sym = 1 , nirrep_

                coulomb_ind  = 0
                exchange_col = 0

                ! loop over w indeces

                do w = 1 , nactpi_(w_sym) !first_index_(w_sym,2) , last_index_(w_sym,2)

                  exchange_row = df_ga_index(n,first_index_(w_sym,2),w_sym) - 1

                  exchange_col = exchange_col + 1

                  ! *** w > v --> factor of 2 

                  ! loop over v indeces

                  do v = 1 , w - 1 !first_index_(w_sym,2) , w -1 

                    den_ind      = den_ind + 1
                    coulomb_ind  = coulomb_ind + 1
                    exchange_row = exchange_row + 1

                    ! :: d1(v|w) * [ 2 * g(mn|vw) - g(mw|wn) ]
                    val = val + den1(den_ind) * ( 2.0_wp * Jm(w_sym)%ints(coulomb_ind,mn_J) - & 
                                             &       Km(w_sym)%ints(exchange_row,exchange_col) )

                  end do ! end v loop

                  ! *** w == v --> factor of 1

                  den_ind      = den_ind + 1
                  coulomb_ind  = coulomb_ind + 1
                  exchange_row = exchange_row + 1

                  ! :: d1(v|w) * [ g(mn|vw) - 0.5 * g(mw|wn) ]
                  val = val + den1(den_ind) * ( Jm(w_sym)%ints(coulomb_ind,mn_J) -       &
                                    & 0.5_wp * Km(w_sym)%ints(exchange_row,exchange_col) )

                end do ! end w loop

              end do ! end w_sym loop

              ! save Fock matrix element
              mn_fock          = ints_%gemind(m,n)
              fock_a_(mn_fock) = val

            end do ! end n loop

#ifdef OMP
!$omp end do nowait
!$omp end parallel
#endif

          end do ! and n_class loop

        end do ! end m loop

      end do ! end m_sym loop

    end do ! end m_class loop

    error = deallocate_df_fa()

    return

    contains

      integer function allocate_df_fa()

        implicit none

        integer :: m_sym,w_sym,nact,n_m,n_w

        allocate(mw_df%m_irr(nirrep_))

        do m_sym = 1 , nirrep_

          allocate(mw_df%m_irr(m_sym)%w_irr(nirrep_))

          n_m = trans_%nmopi(m_sym) 
  
          if ( n_m == 0 ) cycle

          do w_sym = 1 , nirrep_

            n_w = nactpi_(w_sym)

            if ( n_w == 0 ) cycle

            allocate(mw_df%m_irr(m_sym)%w_irr(w_sym)%df_int(df_vars_%nQ,n_m*n_w))
 
          end do

        end do

        allocate(vw_df%w_irr(nirrep_))

        do w_sym = 1 , nirrep_

          n_w = nactpi_(w_sym)

          if ( n_w == 0 ) cycle

          allocate(vw_df%w_irr(w_sym)%df_int(df_vars_%nQ,n_w*(n_w+1)/2))

        end do

        allocate(mn_df%df_int(df_vars_%nQ,max_nmopi))

        do m_sym = 1 , nirrep_

          allocate(Km(m_sym)%ints(max_nactpi*max_nmopi,max_nactpi))

        end do

        do w_sym = 1 , nirrep_

          n_w = nactpi_(w_sym)

          if ( n_w == 0 ) cycle

          allocate(Jm(w_sym)%ints(n_w*(n_w+1)/2,max_nmopi))

        end do
        
        allocate_df_fa = 0

        return

      end function allocate_df_fa

      integer function deallocate_df_fa()

        integer :: m_sym,w_sym

        do m_sym = 1 , nirrep_

          do w_sym = 1 , nirrep_

            if (allocated(mw_df%m_irr(m_sym)%w_irr(w_sym)%df_int)) deallocate(mw_df%m_irr(m_sym)%w_irr(w_sym)%df_int)

          end do

          if (allocated(vw_df%w_irr(m_sym)%df_int)) deallocate(vw_df%w_irr(m_sym)%df_int)

          if (allocated(Km(m_sym)%ints))            deallocate(Km(m_sym)%ints)

          if (allocated(Jm(m_sym)%ints))            deallocate(Jm(m_sym)%ints)

          deallocate(mw_df%m_irr(m_sym)%w_irr)

        end do

        deallocate(mw_df%m_irr)

        deallocate(vw_df%w_irr)

        if (allocated(mn_df%df_int)) deallocate(mn_df%df_int)

        deallocate_df_fa = 0

      end function deallocate_df_fa

  end subroutine compute_f_a_df

  subroutine compute_f_a(den1,int2)
    implicit none
    ! this subroutine computes the "active fock matrix" according to Eq. 12.5.13 in Helgaker on page 622
    ! F_a(m|n) = h(m|n) + SUM[v,w \in A] { g(mn|vw) - 0.5 g(mw|vn) }
    ! Apart from the symmetry constraint m_sym == n_sym and m >= n, m and n can belong to either of the three
    ! orbital classes.
    ! v and w belong to the active orbital class
    real(wp), intent(in) :: den1(:),int2(:)
    integer :: m_class,n_class,m_sym,m,n,v,w,w_sym,mw_sym
    integer :: mn,vw,mw,vn,den_ind
    integer :: int_ind,sym_offset
    real(wp) :: val,ival,dval

    ! initialize
    fock_a_ = 0.0_wp

    ! loop over orbital classes for m

    do m_class = 1 , 3

      ! loop over irreps (m_sym == n_sym for F(m,n) != 0)

      do m_sym = 1 , nirrep_

        ! loop over m indeces

        do m = first_index_(m_sym,m_class) , last_index_(m_sym,m_class)

          ! loop over n indeces ( m_class == n_class && m >= n && m_sym == n_sym )

          do n = first_index_(m_sym,m_class) , m

            ! mn-geminal index
            mn  = ints_%gemind(m,n)
 
            ! initialize Fock matrix element
            val = 0.0_wp
 
            ! loop over irreps for v

            do w_sym = 1 , nirrep_
  
              ! loop over w indeces

              do w = first_index_(w_sym,2) , last_index_(w_sym,2)

                ! loop over v indeces

                do v = first_index_(w_sym,2) , last_index_(w_sym,2)

                  ! 1-e density element
                  den_ind    = dens_%gemind(v,w)
                  dval       = den1(den_ind)

                  ! 2-e coulomb contribution 2 g(mn|vw)
                  vw         = ints_%gemind(v,w)
                  int_ind    = pq_index(mn,vw)
                  ival       = int2(int_ind)

                  ! 2-e exchange contribution - g(mw|vn)
                  mw         = ints_%gemind(m,w)
                  vn         = ints_%gemind(v,n)
                  mw_sym     = group_mult_tab_(m_sym,w_sym)
                  sym_offset = ints_%offset(mw_sym)
                  int_ind    = sym_offset + pq_index(mw,vn)
                  ival       = ival - 0.5_wp * int2(int_ind)

                  ! contract with integral/density matrix elements
                  val        = val + dval * ival

                end do ! end v loop

              end do ! end w loop

            end do ! end w_sym loop

            ! save Fock matrix element
            fock_a_(mn) = val

          end do ! end n loop

          ! loop over orbital classes for n (n_class < m_class --> n < m) 

          do n_class = 1 , m_class - 1

            ! loop over n indeces

            do n = first_index_(m_sym,n_class) , last_index_(m_sym,n_class)

              ! mn-geminal index
              mn  = ints_%gemind(m,n)

              ! initialize Fock matrix element
              val = 0.0_wp

              ! loop over irreps for v

              do w_sym = 1 , nirrep_
  
                ! loop over w indeces

                do w = first_index_(w_sym,2) , last_index_(w_sym,2)

                  ! loop over v indeces

                  do v = first_index_(w_sym,2) , last_index_(w_sym,2)

                    ! 1-e density element
                    den_ind    = dens_%gemind(v,w)
                    dval       = den1(den_ind)

                    ! 2-e coulomb contribution 2 g(mn|vw)
                    vw         = ints_%gemind(v,w)
                    int_ind    = pq_index(mn,vw)
                    ival       = int2(int_ind)

                    ! 2-e exchange contribution - g(mw|vn)
                    mw         = ints_%gemind(m,w)
                    vn         = ints_%gemind(v,n)
                    mw_sym     = group_mult_tab_(m_sym,w_sym)
                    sym_offset = ints_%offset(mw_sym)
                    int_ind    = sym_offset + pq_index(mw,vn)
                    ival       = ival - 0.5_wp * int2(int_ind)

                    ! contract with integral/density matrix elements
                    val        = val + dval * ival

                  end do ! end v loop

                end do ! end w loop
  
              end do ! end w_sym loop

              ! save Fock matrix element
              fock_a_(mn) = val

            end do ! end n loop

          end do ! and n_class loop

        end do ! end m loop

      end do ! end m_sym loop

    end do ! end m_class loop
   
    return
  end subroutine compute_f_a

  subroutine compute_f_i_df(int1,int2)
    ! this subroutine computes the "inactive fock matrix" according to Eq. 12.5.12 in Helgaker on page 622
    ! F_i(m|n) = h(m|n) + SUM[i \in D] { 2 g(mn|ii) - g(mi|in) }
    ! using 3-index 2-e integrals
    ! Apart from the symmetry constraint m_sym == n_sym and m >= n, m and n can belong to either of the three
    ! orbital classes. 
    implicit none
    real(wp), intent(in) :: int1(:),int2(:)
    integer :: m_class,n_class,m_sym,m,n,i,i_sym,mdf,ndf,idf
    integer :: mn_fock,mn_int1
    integer :: error,max_nmopi,max_ndocpi,df_ind
    integer :: mc_f,mc_l,m_dgemm,n_dgemm,k_dgemm
    integer :: ni_K,mi_k,mn_J,ii_J
    integer(ip) :: mn,ii,mi,nQ
    real(wp) :: oeval,exchange,coulomb

    type df_int_block
      real(wp), allocatable :: df_int(:,:)
    end type df_int_block

    type i_sym_block
      type(df_int_block), allocatable :: i_irr(:)
    end type i_sym_block

    type m_sym_block
      type(i_sym_block), allocatable :: m_irr(:)
    end type m_sym_block

    type int_block
      real(wp),  allocatable :: ints(:,:)
    end type int_block

    type(i_sym_block)  :: ii_df
    type(df_int_block) :: mn_df
    type(m_sym_block)  :: mi_df
    type(int_block)    :: Km(nirrep_)
    type(int_block)    :: Jm(nirrep_)

    nQ = int(df_vars_%nQ,kind=ip) 

    max_nmopi  = maxval(trans_%nmopi)
    max_ndocpi = maxval(ndocpi_)

    error = allocate_df_f_i()

    ! ************************************
    ! gather mi df integrals for all m & i
    ! this adds nQ*nmo*ndoc storage
    ! ************************************

    do m_sym = 1 , nirrep_

      if ( trans_%nmopi(m_sym) == 0 ) cycle

      do i_sym = 1 , nirrep_
   
        if ( ndocpi_(i_sym) == 0 ) cycle

        df_ind = 0

        do m_class = 1 , 3

          do m = first_index_(m_sym,m_class) , last_index_(m_sym,m_class)

            mdf = df_vars_%class_to_df_map(m)

            do i = first_index_(i_sym,1) , last_index_(i_sym,1)

              idf    = df_vars_%class_to_df_map(i)

              mi     = df_pq_index(mdf,idf)

              df_ind = df_ind + 1 

              call dcopy(df_vars_%nQ,int2(mi+1:mi+nQ),1,mi_df%m_irr(m_sym)%i_irr(i_sym)%df_int(:,df_ind),1)

            end do

          end do

        end do

      end do

    end do

    ! ************************************
    ! gather all ii df integrals for all i
    ! this adds nQ*ndoc storage
    ! ************************************

    do i_sym = 1 , nirrep_
 
      if ( ndocpi_(i_sym) == 0 ) cycle 

      df_ind = 0
 
      do i = first_index_(i_sym,1) , last_index_(i_sym,1)

        idf    = df_vars_%class_to_df_map(i)
  
        ii     = df_pq_index(idf,idf)

        df_ind = df_ind + 1

        call dcopy(df_vars_%nQ,int2(ii+1:ii+nQ),1,ii_df%i_irr(i_sym)%df_int(:,df_ind),1)

      end do

    end do

    ! initialize
    fock_i_ = 0.0_wp

    ! loop over orbital classes for m

    do m_class = 1 , 3

      ! loop over irreps (m_sym == n_sym for F(m,n) != 0)

      do m_sym = 1 , nirrep_

        ! loop over m indeces

        do m = first_index_(m_sym,m_class) , last_index_(m_sym,m_class)

          ! orbital index in df order
          mdf = df_vars_%class_to_df_map(m)

          ! ****************************************************
          ! gather mn df integrals for this value of m and all n
          ! this adds nQ*nmo storage
          ! ****************************************************

          df_ind = 0 
  
          ! this used to be up to 3
          do n_class = 1 , m_class

            do n = first_index_(m_sym,n_class) , last_index_(m_sym,n_class)

              ndf    = df_vars_%class_to_df_map(n)

              mn     = df_pq_index(mdf,ndf)
 
              df_ind = df_ind + 1
 
              call dcopy(df_vars_%nQ,int2(mn+1:mn+nQ),1,mn_df%df_int(:,df_ind),1)
              
            end do

          end do
 
          ! **********************************************************
          ! form the Coulomb and exchange matrices for this value of m
          ! **********************************************************

          do i_sym =  1 , nirrep_

            m_dgemm = ndocpi_(i_sym) * trans_%nmopi(m_sym)
            n_dgemm = ndocpi_(i_sym)
            k_dgemm = df_vars_%nQ

            if ( ( m_dgemm > 0 ) .and. ( n_dgemm > 0 ) ) then

              mc_f = ( trans_%class_to_irrep_map(m) - 1 ) * n_dgemm
              mc_l = mc_f + n_dgemm
 
              call dgemm('t','n',m_dgemm,n_dgemm,k_dgemm,1.0_wp,                        &
                       & mi_df%m_irr(m_sym)%i_irr(i_sym)%df_int,k_dgemm, &
                       & mi_df%m_irr(m_sym)%i_irr(i_sym)%df_int(:,mc_f+1:mc_l),k_dgemm, &
                     & 0.0_wp,Km(i_sym)%ints(1:m_dgemm,1:n_dgemm),m_dgemm)

            end if

            m_dgemm = ndocpi_(i_sym)
            n_dgemm = df_ind !trans_%nmopi(m_sym)

            if ( ( m_dgemm > 0 ) .and. ( n_dgemm > 0 ) ) then

              call dgemm('t','n',m_dgemm,n_dgemm,k_dgemm,1.0_wp,ii_df%i_irr(i_sym)%df_int, &
                       & k_dgemm,mn_df%df_int(:,1:n_dgemm),k_dgemm,0.0_wp,                 &
                       & Jm(i_sym)%ints(:,1:n_dgemm),m_dgemm)

            end if 

          end do 

          ! loop over n indeces ( m_class == n_class && m >= n && m_sym == n_sym )

#ifdef OMP
!$omp parallel shared(m_sym,m_class,m,nirrep_,first_index_,last_index_,int1,ints_, &
!$omp ndocpi_,trans_,Km,Jm,fock_i_)
!$omp do private(n,mn_int1,oeval,coulomb,exchange,i_sym,ni_K,mi_K,mn_J,mn_fock)
#endif

          do n = first_index_(m_sym,m_class) , m

            ! mn-geminal index
            mn_int1 = ints_%gemind(m,n)

            ! 1-e contribution h(m|n)
            oeval   = int1(mn_int1)

            coulomb  = 0.0_wp
            exchange = 0.0_wp

            ! loop over irreps for i

            do i_sym = 1 , nirrep_

              ! loop over i indeces

              ni_K = ( trans_%class_to_irrep_map(n) - 1 ) * ndocpi_(i_sym)
              mi_K = 0

              if ( ndocpi_(i_sym) > 0 ) then
 
                do i = 1 , ndocpi_(i_sym)

                  ni_K = ni_K + 1
                  mi_K = mi_K + 1
 
                  exchange = exchange + Km(i_sym)%ints(ni_K,mi_K)

                end do

                mn_J = trans_%class_to_irrep_map(n)

                coulomb = coulomb + sum(Jm(i_sym)%ints(1:ndocpi_(i_sym),mn_J))

              end if

            end do ! end i_sym loop

            ! save Fock matrix element

            mn_fock          = ints_%gemind(m,n)
            fock_i_(mn_fock) = oeval + 2.0_wp * coulomb - exchange

          end do ! end n loop

#ifdef OMP
!$omp end do nowait
!$omp end parallel
#endif

          ! loop over orbital classes for n (n_class < m_class --> n < m) 

          do n_class = 1 , m_class - 1

            ! loop over n indeces

#ifdef OMP
!$omp parallel shared(m_sym,n_class,m,nirrep_,first_index_,last_index_,int1,ints_, &
!$omp ndocpi_,trans_,Km,Jm,fock_i_)
!$omp do private(n,mn_int1,oeval,coulomb,exchange,i_sym,ni_K,mi_K,mn_J,mn_fock)
#endif
            do n = first_index_(m_sym,n_class) , last_index_(m_sym,n_class)

              mn_int1 = ints_%gemind(m,n)
              ! 1-e contribution h(m|n)
              oeval   = int1(mn_int1)

              exchange = 0.0_wp
              coulomb  = 0.0_wp

              ! loop over irreps for i

              do i_sym = 1 , nirrep_

                if ( ndocpi_(i_sym) > 0 ) then

                  ni_K = ( trans_%class_to_irrep_map(n) - 1 ) * ndocpi_(i_sym)
                  mi_K = 0

                  do i = 1 , ndocpi_(i_sym)

                    ni_K = ni_K + 1
                    mi_K = mi_K + 1

                    exchange = exchange + Km(i_sym)%ints(ni_K,mi_K)

                  end do

                  mn_J = trans_%class_to_irrep_map(n)

                  coulomb = coulomb + sum(Jm(i_sym)%ints(1:ndocpi_(i_sym),mn_J))
  
                end if

              end do ! end i_sym loop

              ! save Fock matrix element
              mn_fock          = ints_%gemind(m,n)
              fock_i_(mn_fock) = oeval + 2.0_wp * coulomb - exchange

            end do ! end n_loop

#ifdef OMP
!$omp end do nowait
!$omp end parallel
#endif

          end do ! end n_class loop

        end do ! end m_loop

      end do ! end m_sym loop

    end do ! end m_class loop

    error = deallocate_df_f_i()

    return

    contains

      integer function allocate_df_f_i()

        integer :: m_sym,i_sym
        integer :: n_m,n_i
 
        allocate(mi_df%m_irr(nirrep_))
       
        do m_sym = 1 , nirrep_
  
          allocate(mi_df%m_irr(m_sym)%i_irr(nirrep_))

          n_m = trans_%nmopi(m_sym)

          if ( n_m == 0 ) cycle

          do i_sym = 1 , nirrep_

            n_i = ndocpi_(i_sym)

            if ( n_i == 0 ) cycle

            allocate(mi_df%m_irr(m_sym)%i_irr(i_sym)%df_int(df_vars_%nQ,n_i*n_m))

          end do
            
        end do

        allocate(ii_df%i_irr(nirrep_))

        do i_sym = 1 , nirrep_

          n_i = ndocpi_(i_sym)

          if ( n_i == 0 ) cycle

          allocate(ii_df%i_irr(i_sym)%df_int(df_vars_%nQ,n_i))

        end do

        allocate(mn_df%df_int(df_vars_%nQ,max_nmopi))

        do i_sym = 1 , nirrep_

          if ( ( max_nmopi == 0 ) .or. ( max_ndocpi == 0 ) ) cycle

          allocate(Km(i_sym)%ints(max_nmopi*max_ndocpi,max_ndocpi))

        end do

        do i_sym = 1 , nirrep_

          n_i = ndocpi_(i_sym)

          if ( n_i == 0 ) cycle

          allocate(Jm(i_sym)%ints(n_i,max_nmopi))

        end do

        allocate_df_f_i = 0
 
        return

      end function allocate_df_f_i

      integer function deallocate_df_f_i()

        integer :: m_sym,i_sym

        do m_sym = 1 , nirrep_

         do i_sym = 1 , nirrep_

           if ( allocated(mi_df%m_irr(m_sym)%i_irr(i_sym)%df_int) ) deallocate(mi_df%m_irr(m_sym)%i_irr(i_sym)%df_int)

         end do

         if ( allocated(ii_df%i_irr(m_sym)%df_int) ) deallocate(ii_df%i_irr(m_sym)%df_int)

         if ( allocated(Km(m_sym)%ints) ) deallocate(Km(m_sym)%ints)

         if ( allocated(Jm(m_sym)%ints) ) deallocate(Jm(m_sym)%ints)

         deallocate(mi_df%m_irr(m_sym)%i_irr)

        end do

        deallocate(mi_df%m_irr)

        deallocate(ii_df%i_irr)

        if ( allocated(mn_df%df_int) ) deallocate(mn_df%df_int)

        deallocate_df_f_i = 0

        return

      end function deallocate_df_f_i

  end subroutine compute_f_i_df

  subroutine compute_f_i(int1,int2)
    ! this subroutine computes the "inactive fock matrix" according to Eq. 12.5.12 in Helgaker on page 622
    ! F_i(m|n) = h(m|n) + SUM[i \in D] { 2 g(mn|ii) - g(mi|in) }
    ! Apart from the symmetry constraint m_sym == n_sym and m >= n, m and n can belong to either of the three
    ! orbital classes. 
    implicit none
    real(wp), intent(in) :: int1(:),int2(:)
    integer :: m_class,n_class,m_sym,m,n,i,i_sym,mi_sym
    integer :: mn,ii,mi,in
    integer :: int_ind,sym_offset
    real(wp) :: val

    ! initialize
    fock_i_ = 0.0_wp

    ! loop over orbital classes for m

    do m_class = 1 , 3

      ! loop over irreps (m_sym == n_sym for F(m,n) != 0)

      do m_sym = 1 , nirrep_

        ! loop over m indeces

        do m = first_index_(m_sym,m_class) , last_index_(m_sym,m_class)

          ! loop over n indeces ( m_class == n_class && m >= n && m_sym == n_sym )

          do n = first_index_(m_sym,m_class) , m

            ! mn-geminal index
            mn = ints_%gemind(m,n)
            ! 1-e contribution h(m|n)
            val = int1(mn)

            ! loop over irreps for i

            do i_sym = 1 , nirrep_

              ! loop over i indeces

              do i = first_index_(i_sym,1) , last_index_(i_sym,1)

                ! 2-e coulomb contribution 2 g(mn|ii)
                ii         = ints_%gemind(i,i)
                int_ind    = pq_index(ii,mn)
                val        = val + 2.0_wp * int2(int_ind)

                ! 2-e exchange contribution - g(mi|in)
                mi         = ints_%gemind(m,i)
                in         = ints_%gemind(i,n)
                mi_sym     = group_mult_tab_(m_sym,i_sym)
                sym_offset = ints_%offset(mi_sym)
                int_ind    = sym_offset + pq_index(mi,in)
                val        = val - int2(int_ind) 

              end do ! end i loop

            end do ! end i_sym loop

            ! save Fock matrix element
            fock_i_(mn) = val

          end do ! end n loop

          ! loop over orbital classes for n (n_class < m_class --> n < m) 

          do n_class = 1 , m_class - 1

            ! loop over n indeces

            do n = first_index_(m_sym,n_class) , last_index_(m_sym,n_class)

              mn = ints_%gemind(m,n)
              ! 1-e contribution h(m|n)
              val = int1(mn) 

              ! loop over irreps for i

              do i_sym = 1 , nirrep_

                ! loop over i indeces

                do i = first_index_(i_sym,1) , last_index_(i_sym,1)

                  ! 2-e coulomb contribution 2 g(mn|ii)
                  ii         = ints_%gemind(i,i)
                  int_ind    = pq_index(ii,mn)
                  val        = val + 2.0_wp * int2(int_ind)

                  ! 2-e exchange contribution - g(mi|in)
                  mi         = ints_%gemind(m,i)
                  in         = ints_%gemind(i,n)
                  mi_sym     = group_mult_tab_(m_sym,i_sym)
                  sym_offset = ints_%offset(mi_sym)
                  int_ind    = sym_offset + pq_index(mi,in)
                  val        = val - int2(int_ind)

                end do ! end i loop
 
              end do ! end i_sym loop

              ! save Fock matrix element
              fock_i_(mn) = val

            end do ! end n_loop

          end do ! end n_class loop

        end do ! end m_loop

      end do ! end m_sym loop
  
    end do ! end m_class loop

    return
  end subroutine compute_f_i

  integer function precondition_gradient(precond,gradient)
    implicit none
    ! simple subroutine to precondition the gradient according to
    ! g(i) = g(i)/precond(i) if (precond(i) >  0
    !      = g(i)            if (precond(i) <= 0
    real(wp) :: gradient(:)
    real(wp) :: precond(:)

    integer :: n_ij,ij_pair,nij_negative

    precondition_gradient = 1
  
    n_ij=size(gradient)
     
    if (n_ij /= size(precond) ) return

    nij_negative = 0

    do ij_pair = 1 , n_ij

      if ( precond(ij_pair) > 0.0_wp ) then
        gradient(ij_pair) = gradient(ij_pair) / precond(ij_pair)
      else
        gradient(ij_pair) = 0.0_wp
        nij_negative = nij_negative + 1
      endif    

    end do

    precondition_gradient = 0

    if ( ( nij_negative /= 0 ) .and. ( log_print_ == 1 ) ) then
      write(fid_,'(a,1x,i9,1x,a)')'!warning!',nij_negative,'diagonal Hessian elements were negative'
      call flush(fid_)
    end if

    return

  end function precondition_gradient
 
  subroutine allocate_temporary_fock_matrices()
    implicit none
    ! the total number of nonzero LT elements in the active/inactive Fock matrix 
    ! is equal to the number of geminals in the totally symmetric irrep
    allocate(fock_i_(ints_%ngempi(1)))
    allocate(fock_a_(ints_%ngempi(1)))
    ! the row index here will be between 1-nact, while the column index is arbitrary
    allocate(q_(nact_tot_,nmo_tot_))
    allocate(z_(nact_tot_,nmo_tot_))
    ! generalized Fock matrix
    !
    !        | F_dd F_da F_dv |   | F_dd F_da F_dv |
    !F_gen = | F_ad F_aa F_av | = | F_ad F_aa F_av |
    !        | F_vd F_va F_vv |   |  0    0    0   |
    !
    ! thus here we allocate more than needed, but that is not too much memory
    !allocate(fock_gen_(nmo_tot_,nmo_tot_))
    return
  end subroutine allocate_temporary_fock_matrices

  subroutine deallocate_temporary_fock_matrices()
    implicit none
    if (allocated(fock_i_))   deallocate(fock_i_)
    if (allocated(fock_a_))   deallocate(fock_a_)
    if (allocated(q_))        deallocate(q_)
    if (allocated(z_))        deallocate(z_)
    !if (allocated(fock_gen_)) deallocate(fock_gen_)
    return
  end subroutine deallocate_temporary_fock_matrices

end module focas_gradient
